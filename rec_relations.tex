\chapter{Well-Typed Recurrence Relations}
Karp's paper is premised on the notion that algorithms with stochastic processes may be described as 
recurrence relations of the form
\begin{align*}
T(x) = a(x) + T(h_1(x)) + \dots + T(h_n(x)).
\end{align*}
But what does this equation actually mean? To unpack this, we will attempt to assign types to this recurrence

 Following Karp's definitions, we can immediately assign types to some of these terms:
\begin{align*}
T(x) &: \Omega_x \rightarrow \R \text{, where } \Omega_x \text{ is the sample space of all problem instances of size } x \\
T &: \prod_{x \in \R} (\Omega_x \rightarrow \R) \\ 
a &: \R \rightarrow \R
\end{align*}

However, for other terms it is less clear what the type should should be. Karp alternates between saying that $h$ is a random 
variable and $h(x)$ is a random variable, so it is not immediately obvious 
what the meaning of this function is. However, since $h$ takes $x \in \R$ as an input, it would not make sense for $h$ to be a 
random variable from $\R \rightarrow \R$. This would make $h$ a function that takes an input size and returns the 
size of the derived subproblem---thus sidestepping the stochastic part of the algorithm. Then it must be that $h(x)$ is a random
variable that takes a \emph{specific input} of size $x$ and returns the size of the derived subproblem.
\begin{align*}
h_i(x) &: \Omega_x \rightarrow \R \\
h_i &: \prod_{x \in \R}(\Omega_x \rightarrow \R) 
\end{align*} 

There are some inconsistencies in these type assignments. To start, $T$ is a function that takes a real number and 
returns a random variable. But on the right-hand side of the relation, $T$ takes $h_i(x)$ as an argument; $h_i(x)$ is
not a real number, but a random variable. 

Thinking in terms of what we \emph{want} this recurrence to express, the arguments to the $T$'s on the righthand side of
the equation should be the sizes of the derived subproblems---that is, the result of applying $h_i(x)$ to the original input.
Then, given an input $l \in \Omega_x$, we should have
\begin{align*}
T(x)(l) &= a(x) + T(h_1(x)(l)) \dots + T(h_n(x)(l)) \\
&\text{where } h(x)(l) : \R 
\end{align*}
 Thus, the term $T(h_i(x)(l))$ typechecks. However, we now run into another problem: $T(x)(l)$ and $a(x)$ are real numbers,
but $T(h_i(x)(l))$ is a random variable of type $\Omega_{h_i(x)(l)} \rightarrow \R$. Then $T(h_i(x)(l))$ needs an argument.
Consider that $T(h_i(x)(l))$ is a random variable describing the running time of the algorithm with an input of size 
$h_i(x)(l)$. For instance, given a recurrence for randomized quicksort, $T(h_1(x)(l))$ and $T(h_2(x)(l))$ describe how long it 
takes to quicksort the left and right sublists of an input list $l$, which themselves have length $h_1(x)(l)$ and
$h_2(x)(l)$. The arguments to these random variables, then, should be the left and right sublists themselves. 

 In order for us to obtain these sublists, it will be necessary for us to define a function 
 \begin{align*}
 \hat{h_i}(x) &: \prod_{l \in \Omega_x} \Omega_{h_i(x)(l)} \\
 \hat{h_i} &: \prod_{x \in R} \ ( \prod_{l \in \Omega_x} \Omega_{h_i(x)(l)})
 \end{align*}
 such that $\hat{h_i}(x)$ takes an input of size $x$ and returns the derived subproblem of size $h_i(x)(l)$. See, then, that
 $T(h_i(x)(l))(\hat{h_i}(x)(l))$ has type $\R$. So, this leaves us with the equation
 \begin{align*}
 T(x)(l) &= a(x) + T(h_1(x)(l))(\hat{h_1}(x)(l)) \dots + T(h_n(x)(l))(\hat{h_n}(x)(l))
 \end{align*}
 which, finally, typechecks.
 
 Thus, we find that attempting to formally assigns types to Karp's probabilistic recurrences reveals a lot of hidden 
 complications and ambiguities, which Karp never addresses directly. Most notably, we find that the types of the 
 functions $T, \ h, and \hat{h}$ are dependent upon a real number $x$, describing the size of problems in the sample space.
 
We define a syntax to write and type-check these recurrences. This syntax is based on $\lambda$LF---a simple system of 
dependent types. 
 
 \[
\begin{array}{rcl}
\tau &::=& X \mid \texttt{real} \mid \texttt{nat} \mid \texttt{bool} \mid \tau \times \tau \mid \tau \rightarrow \tau \mid \Pi x:\tau.\tau
\mid \tau \ e \mid \texttt{list(x)}? \\
k &::=& * \mid \Pi x : \tau.k \\
e &::=& x  \mid \texttt{0} \mid \texttt{1} \mid \texttt{2} \mid \dotsc \mid \lambda x.e \mid e \ e \mid e + e \mid e - e \mid  e  *  e \mid e / e \mid \texttt{true} \mid \texttt{false} \mid \\
  && e  =  e \mid e < e \mid e > e \ | e \leq e \mid e \geq e \mid 
     \ifelse{e}{e}{e} \mid \texttt{rec}(e, e, e) \\
\end{array}
\]

In this syntax, we replace the arrow type $\sigma \rightarrow \tau$ with the dependent product type
$\Pi x:\sigma.\tau$, and introduce type families. These are collections of types that depend on some input: for instance,
the type $\Pi x:\texttt{real}.list(x)$, where the type $list(x)$ is dependent upon an input $x$ of type \texttt{real}.
The syntax consists of entities of three levels: expressions, types, and kinds. The inclusion of kinds lets us
differentiate between proper types, $*$, and type families.

\section{Well-formed Kinds}
\[
\begin{array}{c}
\Gamma \vdash * \\ \\
\dfrac{\Gamma \vdash \tau :: * \ \ \ \Gamma,x:\tau \vdash k}{\Gamma \vdash \Pi x:\tau.k} \\
\end{array}
\]

\section{Kinding}
\begin{figure}[H]
\[
\begin{array}{c}
\dfrac{X :: k \in \Gamma \ \ \ \Gamma \vdash k}{\Gamma \vdash X :: k} \\ \\
\dfrac{\Gamma \vdash \tau_1 :: * \ \ \ \Gamma, x:\tau_1 \vdash \tau_2 :: *}{\Gamma \vdash \Pi x:\tau_1.\tau_2 :: *} \\ \\
\dfrac{\Gamma \vdash S :: \Pi x:\tau.k \ \ \ \Gamma \vdash e : \tau}{\Gamma \vdash S \ e : [x \mapsto t]k} \\ \\
\end{array}
\]
\end{figure}

\section{Kind/Type equivalence?}

\section{Typing}
\begin{figure}[H]
\[
\begin{array}{lr}
\Gamma \vdash \texttt{real} :: * \\ \\
\Gamma \vdash \texttt{bool} :: * \\ \\
\dfrac{}{\Gamma \vdash \texttt{0}: \texttt{real}}, \ \ \dfrac{}{\Gamma \vdash \texttt{1}: \texttt{real}}, \ldots \\ \\
\dfrac{}{\Gamma \vdash \texttt{true} : \texttt{bool}}, \ \ \dfrac{}{\Gamma \vdash \texttt{false} : \texttt{bool}} \\  \\
\dfrac{x : \tau \in \Gamma \ \ \ \Gamma \vdash \tau :: *}{\Gamma \vdash x : \tau } \\ \\ 
\dfrac{\Gamma \vdash \sigma :: * \ \ \ \Gamma, x : \sigma \vdash e : \tau}
	{\Gamma \vdash \lambda (x : \sigma).e : \Pi x:\sigma.\tau } \\ \\
\dfrac{\Gamma \vdash e_1: \Pi x:\sigma.\tau \ \ \ \Gamma \vdash e_2 : \sigma}
	{\Gamma \vdash e_1 \ e_2 : [x \mapsto e_2]\tau} \\ \\
\dfrac{\Gamma \vdash e_1 : \texttt{real} \ \ \ \Gamma \vdash e_2 : \texttt{real}}
	{\Gamma \vdash e_1 \circ e_2 : \texttt{real}}
, \circ \in \{+,-,*,/\} \\ \\ 
\dfrac{\Gamma \vdash e_1 : \texttt{real} \ \ \ \Gamma \vdash e_2 : \texttt{real}}
	{\Gamma \vdash e_1 \circ e_2 : \texttt{bool}}
	, \circ \in \{=, <, >, \geq, \leq\} \\ \\ 
\dfrac{\Gamma \vdash e_1 : \texttt{bool} \ \ \ \Gamma \vdash e_2 : \tau \ \ \ \Gamma \vdash e_3 : \tau}
	{\Gamma \vdash \ifelse{e_1}{e_2}{e_3} : \tau} \\ \\ 
\dfrac{\Gamma \vdash e_1 : \Pi x : \texttt{real}.\texttt{real} \ \ \ \Gamma \vdash e_2 : 
\Pi x : \texttt{list(n)} . \texttt{real} \ \ \ \Gamma \vdash e_3 : \Pi x: \texttt{list(n)}.\texttt{list(}e_2(x)\texttt{)}}
	{\Gamma \vdash \texttt{rec}(e_1, e_2, e_3) : \Pi x : \texttt{list(n)} . \texttt{real}} \\ \\ 
\end{array}
\]
\end{figure}

\section{Denotational Semantics}
 
