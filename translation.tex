\chapter{Reconciling the Two Semantics}
In this chapter, we look at several attempts to connect the recurrences described in chapters 2 and 3. We will offer
several methods of translating from one expression language to the other, and investigate the validity of these approaches.

As a first attempt, we consider a simple recurrence with an initial condition
\begin{align*}
T(1) &= 0 \\
T(n) &= 1 + T(n/2 ) 
\end{align*}
(for simplicity, suppose that the domain of $T$ is positive powers of $2$).

This is the kind of recurrence described in chapter 3. In order to make this fit the definition of a recurrence described in 
chapter 2 --- that is, a recurrence of the form $T(n) = a(n) + T(m(n))$, we may interpret $a$ as a 
piecewise function with two sub-functions: one for the general recurrence and one for the initial condition.
We can instead write this as a single recurrence
\begin{align*}
T(n) &= a(n) + T(m(n)) \\
m(n) &= n/2, \ \forall n \\ 
a(n) &=
\begin{cases} 
0, \ n \leq 1 \\
1, \ n > 1
\end{cases}
\end{align*} 
This recurrence can then by expressed in our chapter 2 syntax as 
\begin{align*}
\texttt{T} &= \texttt{rec}(\texttt{a},\texttt{m}) \\
\texttt{m} &= \lambda x.x/\texttt{2} \\
\texttt{a} &= \lambda x.\ifelse{x\leq\texttt{1}}{\texttt{0}}{\texttt{1}} \\
\llbracket \texttt{T} \rrbracket(d) &= \llbracket \texttt{rec}(\texttt{a},\texttt{m}) \rrbracket(d) \\
&= \sum_{i=0}^{\infty}\llbracket \texttt{a} \rrbracket(\llbracket \texttt{m}\rrbracket^i(d)) \\
&= \sum_{i=0}^{\log(n)-1} 1 + \sum_{i=log(n)}^{\infty} 0 \\
&= \log(n) - 1
\end{align*}

However, this approach will not work in every case. Let us try to use the same process on the following recurrence
\begin{align*}
T(1) &= 1 \\
T(n) &= 2 + T(n/2) 
\end{align*}
We first write this as a single recurrence. See that, unlike the previous example, $a$ never maps to $0$.
\begin{align*}
T(n) &= a(n) + T(m(n)) \\
m(n) &= n/2, \ \forall n \\ 
a(n) &= 
\begin{cases}
1, \ n \leq 1 \\
2, \ n > 1
\end{cases}
\end{align*}
We then express this recurrence using our chapter 2 syntax as
\begin{align*}
\texttt{T} &= \texttt{rec}(\texttt{a},\texttt{m}) \\
\texttt{m} &= \lambda x.x/\texttt{2} \\
\texttt{a} &=\lambda x.\ifelse{x\leq\texttt{1}}{\texttt{1}}{\texttt{2}} \\
\llbracket \texttt{T} \rrbracket(d) &= \llbracket \texttt{rec}(\texttt{a},\texttt{m}) \rrbracket(d) \\
&= \sum_{i=0}^{\infty}\llbracket \texttt{a} \rrbracket(\llbracket \texttt{m}\rrbracket^i(d)) \\
&= \sum_{i=0}^{\log(n)-1} 2 + \sum_{i=\log(n) }^{\infty} 1 \\
&= \infty
\end{align*}
Which, clearly, is not a correct solution to this recurrence.

A second attempt takes a similar approach to writing a recurrence with an initial condition as a recurrence of 
the form $T(n) = a(n) + T(m(n))$. Suppose that we interpret $a$ as a piecewise function with three sub-functions:
one for the general recurrence, one for the initial condition, and one for values smaller than the initial condition, which all
map to $0$. Considering the example that failed in the previous attempt, we would have
\begin{align*}
T(n) &= a(n) + T(m(n)) \\
m &= n/2, \forall n \\
a(n) &=
\begin{cases}
0, \ n < 1 \\
1, \ n = 1 \\
2, \ n > 1
\end{cases} \\
\end{align*}
We can express this recurrence using our fixpoint syntax as
\begin{align*}
\texttt{T} &= \texttt{rec}(\texttt{a},\texttt{m}) \\
\texttt{m} &= \lambda x.x/\texttt{2} \\
\texttt{a} &= \lambda x.\ifelse{x <1}{0}{(\ifelse{x = 1}{1}{2})} \\
\llbracket \texttt{a} \rrbracket(d) &= 
%\begin{cases}
%0, \ d < 1 \\
%\llbracket \ifelse{x=1}{1}{2}\rrbracket\{x \mapsto d\}, \ d \geq 1
%\end{cases} \\
 \begin{cases}
0, \ d < 1 \\
1, \ d = 1 \\
2, \ d > 1 
\end{cases} \\
\llbracket \texttt{T} \rrbracket(d) &= \llbracket \texttt{rec}(\texttt{a},\texttt{m})\rrbracket(d) \\
&= \sum_{i=0}^{\infty}\llbracket \texttt{a} \rrbracket(\llbracket \texttt{m}\rrbracket^i(d)) \\
&= \sum_{i=0}^{\log(n)-1} 2 + \sum_{i=\log(n) }^{\log(n)} 1 + \sum_{i = \log(n) + 1}^{\infty} 0 \\
&= 2\log(n) - 1
\end{align*}

This approach matches our intuition for how an initial condition should work---that once you reach the initial condition,
you stop recursing. 

 